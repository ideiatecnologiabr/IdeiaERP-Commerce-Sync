{"ast":null,"code":"import { HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';\nimport { throwError, BehaviorSubject } from 'rxjs';\nimport { catchError, switchMap, filter, take } from 'rxjs/operators';\nimport { AuthService } from '../auth/auth.service';\nimport { Router } from '@angular/router';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../auth/auth.service\";\nimport * as i2 from \"@angular/router\";\nexport class AuthInterceptor {\n  constructor(authService, router) {\n    this.authService = authService;\n    this.router = router;\n    this.isRefreshing = false;\n    this.refreshTokenSubject = new BehaviorSubject(null);\n  }\n  intercept(req, next) {\n    // Adicionar token ao header se disponível\n    const token = this.authService.getToken();\n    let authReq = req;\n    if (token) {\n      authReq = req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n    }\n    return next.handle(authReq).pipe(catchError(error => {\n      // Se for erro 401 (não autorizado)\n      if (error.status === 401 && !this.isRefreshing) {\n        // Tentar renovar token\n        return this.handle401Error(authReq, next);\n      }\n      // Se estiver tentando refresh e ainda der 401, fazer logout\n      if (error.status === 401 && this.isRefreshing) {\n        this.authService.logout();\n        return throwError(() => error);\n      }\n      return throwError(() => error);\n    }));\n  }\n  handle401Error(req, next) {\n    if (!this.isRefreshing) {\n      this.isRefreshing = true;\n      this.refreshTokenSubject.next(null);\n      return this.authService.refreshToken().pipe(switchMap(response => {\n        this.isRefreshing = false;\n        if (response.success && response.data?.token) {\n          this.refreshTokenSubject.next(response.data.token);\n          // Repetir requisição original com novo token\n          const newToken = response.data.token;\n          const clonedReq = req.clone({\n            setHeaders: {\n              Authorization: `Bearer ${newToken}`\n            }\n          });\n          return next.handle(clonedReq);\n        }\n        // Se refresh falhou, fazer logout\n        this.authService.logout();\n        return throwError(() => new Error('Token refresh failed'));\n      }), catchError(error => {\n        this.isRefreshing = false;\n        this.authService.logout();\n        return throwError(() => error);\n      }));\n    } else {\n      // Se já está tentando refresh, esperar o resultado\n      return this.refreshTokenSubject.pipe(filter(token => token !== null), take(1), switchMap(token => {\n        const clonedReq = req.clone({\n          setHeaders: {\n            Authorization: `Bearer ${token}`\n          }\n        });\n        return next.handle(clonedReq);\n      }));\n    }\n  }\n  static {\n    this.ɵfac = function AuthInterceptor_Factory(t) {\n      return new (t || AuthInterceptor)(i0.ɵɵinject(i1.AuthService), i0.ɵɵinject(i2.Router));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AuthInterceptor,\n      factory: AuthInterceptor.ɵfac\n    });\n  }\n}","map":{"version":3,"names":["HttpRequest","HttpHandler","HttpEvent","HttpErrorResponse","throwError","BehaviorSubject","catchError","switchMap","filter","take","AuthService","Router","AuthInterceptor","constructor","authService","router","isRefreshing","refreshTokenSubject","intercept","req","next","token","getToken","authReq","clone","setHeaders","Authorization","handle","pipe","error","status","handle401Error","logout","refreshToken","response","success","data","newToken","clonedReq","Error","i0","ɵɵinject","i1","i2","factory","ɵfac"],"sources":["/Users/ceo/projects/ideia/IdeiaVirtualShop/apps/web/src/app/core/interceptors/auth.interceptor.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport {\n  HttpInterceptor,\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpErrorResponse,\n} from '@angular/common/http';\nimport { Observable, throwError, BehaviorSubject } from 'rxjs';\nimport { catchError, switchMap, filter, take } from 'rxjs/operators';\nimport { AuthService } from '../auth/auth.service';\nimport { Router } from '@angular/router';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  private isRefreshing = false;\n  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\n\n  constructor(\n    private authService: AuthService,\n    private router: Router\n  ) {}\n\n  intercept(\n    req: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    // Adicionar token ao header se disponível\n    const token = this.authService.getToken();\n    let authReq = req;\n\n    if (token) {\n      authReq = req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${token}`,\n        },\n      });\n    }\n\n    return next.handle(authReq).pipe(\n      catchError((error: HttpErrorResponse) => {\n        // Se for erro 401 (não autorizado)\n        if (error.status === 401 && !this.isRefreshing) {\n          // Tentar renovar token\n          return this.handle401Error(authReq, next);\n        }\n\n        // Se estiver tentando refresh e ainda der 401, fazer logout\n        if (error.status === 401 && this.isRefreshing) {\n          this.authService.logout();\n          return throwError(() => error);\n        }\n\n        return throwError(() => error);\n      })\n    );\n  }\n\n  private handle401Error(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (!this.isRefreshing) {\n      this.isRefreshing = true;\n      this.refreshTokenSubject.next(null);\n\n      return this.authService.refreshToken().pipe(\n        switchMap((response: any) => {\n          this.isRefreshing = false;\n          \n          if (response.success && response.data?.token) {\n            this.refreshTokenSubject.next(response.data.token);\n            \n            // Repetir requisição original com novo token\n            const newToken = response.data.token;\n            const clonedReq = req.clone({\n              setHeaders: {\n                Authorization: `Bearer ${newToken}`,\n              },\n            });\n            \n            return next.handle(clonedReq);\n          }\n\n          // Se refresh falhou, fazer logout\n          this.authService.logout();\n          return throwError(() => new Error('Token refresh failed'));\n        }),\n        catchError((error) => {\n          this.isRefreshing = false;\n          this.authService.logout();\n          return throwError(() => error);\n        })\n      );\n    } else {\n      // Se já está tentando refresh, esperar o resultado\n      return this.refreshTokenSubject.pipe(\n        filter((token) => token !== null),\n        take(1),\n        switchMap((token) => {\n          const clonedReq = req.clone({\n            setHeaders: {\n              Authorization: `Bearer ${token}`,\n            },\n          });\n          return next.handle(clonedReq);\n        })\n      );\n    }\n  }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}