{"ast":null,"code":"import { Router } from '@angular/router';\nimport { BehaviorSubject, throwError } from 'rxjs';\nimport { map, catchError } from 'rxjs/operators';\nimport { ApiService } from '../api/api.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../api/api.service\";\nimport * as i2 from \"@angular/router\";\nexport class AuthService {\n  constructor(api, router) {\n    this.api = api;\n    this.router = router;\n    this.currentUserSubject = new BehaviorSubject(null);\n    this.currentUser$ = this.currentUserSubject.asObservable();\n    this.TOKEN_KEY = 'auth_token';\n    this.REFRESH_TOKEN_KEY = 'auth_refresh_token';\n    this.checkAuth();\n  }\n  /**\n   * Realiza login e salva tokens\n   */\n  login(credentials) {\n    return this.api.post('/auth/login', credentials).pipe(map(response => {\n      if (response.success && response.data) {\n        // Salvar tokens\n        this.setToken(response.data.token);\n        this.setRefreshToken(response.data.refreshToken);\n        // Atualizar usuário atual\n        if (response.data.usuario) {\n          this.currentUserSubject.next(response.data.usuario);\n        }\n      }\n      return response;\n    }));\n  }\n  /**\n   * Realiza logout e remove tokens\n   */\n  logout() {\n    // O token será enviado automaticamente pelo interceptor\n    this.api.post('/auth/logout', {}).subscribe({\n      next: () => {\n        this.clearTokens();\n        this.currentUserSubject.next(null);\n        this.router.navigate(['/login']);\n      },\n      error: () => {\n        // Mesmo se falhar, limpar tokens localmente\n        this.clearTokens();\n        this.currentUserSubject.next(null);\n        this.router.navigate(['/login']);\n      }\n    });\n  }\n  /**\n   * Obtém informações do usuário atual\n   */\n  getCurrentUser() {\n    return this.api.get('/auth/me');\n  }\n  /**\n   * Renova o token usando refresh token\n   */\n  refreshToken() {\n    const refreshToken = this.getRefreshToken();\n    if (!refreshToken) {\n      return throwError(() => new Error('Refresh token não encontrado'));\n    }\n    return this.api.post('/auth/refresh', {\n      refreshToken\n    }).pipe(map(response => {\n      if (response.success && response.data) {\n        // Atualizar tokens\n        this.setToken(response.data.token);\n        this.setRefreshToken(response.data.refreshToken);\n        return response;\n      }\n      throw new Error('Falha ao renovar token');\n    }), catchError(error => {\n      // Se refresh falhar, fazer logout\n      this.clearTokens();\n      this.currentUserSubject.next(null);\n      this.router.navigate(['/login']);\n      return throwError(() => error);\n    }));\n  }\n  /**\n   * Verifica se o usuário está autenticado\n   */\n  isAuthenticated() {\n    return this.getToken() !== null && this.currentUserSubject.value !== null;\n  }\n  /**\n   * Obtém o token atual\n   */\n  getToken() {\n    return localStorage.getItem(this.TOKEN_KEY);\n  }\n  /**\n   * Obtém o refresh token atual\n   */\n  getRefreshToken() {\n    return localStorage.getItem(this.REFRESH_TOKEN_KEY);\n  }\n  /**\n   * Salva o token\n   */\n  setToken(token) {\n    localStorage.setItem(this.TOKEN_KEY, token);\n  }\n  /**\n   * Salva o refresh token\n   */\n  setRefreshToken(refreshToken) {\n    localStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);\n  }\n  /**\n   * Remove todos os tokens\n   */\n  clearTokens() {\n    localStorage.removeItem(this.TOKEN_KEY);\n    localStorage.removeItem(this.REFRESH_TOKEN_KEY);\n  }\n  /**\n   * Verifica autenticação ao inicializar\n   */\n  checkAuth() {\n    const token = this.getToken();\n    if (!token) {\n      this.currentUserSubject.next(null);\n      return;\n    }\n    // Tentar obter informações do usuário\n    this.getCurrentUser().subscribe({\n      next: response => {\n        if (response.success && response.data?.usuario) {\n          this.currentUserSubject.next(response.data.usuario);\n        } else {\n          // Token inválido, limpar\n          this.clearTokens();\n          this.currentUserSubject.next(null);\n        }\n      },\n      error: () => {\n        // Erro ao validar token, tentar refresh\n        this.refreshToken().subscribe({\n          next: () => {\n            // Token renovado, tentar novamente\n            this.getCurrentUser().subscribe({\n              next: response => {\n                if (response.success && response.data?.usuario) {\n                  this.currentUserSubject.next(response.data.usuario);\n                }\n              },\n              error: () => {\n                this.clearTokens();\n                this.currentUserSubject.next(null);\n              }\n            });\n          },\n          error: () => {\n            // Refresh falhou, limpar tudo\n            this.clearTokens();\n            this.currentUserSubject.next(null);\n          }\n        });\n      }\n    });\n  }\n  static {\n    this.ɵfac = function AuthService_Factory(t) {\n      return new (t || AuthService)(i0.ɵɵinject(i1.ApiService), i0.ɵɵinject(i2.Router));\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: AuthService,\n      factory: AuthService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["Router","BehaviorSubject","throwError","map","catchError","ApiService","AuthService","constructor","api","router","currentUserSubject","currentUser$","asObservable","TOKEN_KEY","REFRESH_TOKEN_KEY","checkAuth","login","credentials","post","pipe","response","success","data","setToken","token","setRefreshToken","refreshToken","usuario","next","logout","subscribe","clearTokens","navigate","error","getCurrentUser","get","getRefreshToken","Error","isAuthenticated","getToken","value","localStorage","getItem","setItem","removeItem","i0","ɵɵinject","i1","i2","factory","ɵfac","providedIn"],"sources":["/Users/ceo/projects/ideia/IdeiaVirtualShop/apps/web/src/app/core/auth/auth.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { BehaviorSubject, Observable, throwError } from 'rxjs';\nimport { map, catchError, switchMap } from 'rxjs/operators';\nimport { ApiService } from '../api/api.service';\n\nexport interface Usuario {\n  usuario_id: number;\n  nome: string;\n  email: string;\n}\n\nexport interface LoginRequest {\n  email: string;\n  senha: string;\n}\n\nexport interface LoginResponse {\n  usuario: Usuario;\n  token: string;\n  refreshToken: string;\n  expiresAt: string;\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  private currentUserSubject = new BehaviorSubject<Usuario | null>(null);\n  public currentUser$ = this.currentUserSubject.asObservable();\n  \n  private readonly TOKEN_KEY = 'auth_token';\n  private readonly REFRESH_TOKEN_KEY = 'auth_refresh_token';\n\n  constructor(\n    private api: ApiService,\n    private router: Router\n  ) {\n    this.checkAuth();\n  }\n\n  /**\n   * Realiza login e salva tokens\n   */\n  login(credentials: LoginRequest): Observable<any> {\n    return this.api.post<LoginResponse>('/auth/login', credentials).pipe(\n      map((response) => {\n        if (response.success && response.data) {\n          // Salvar tokens\n          this.setToken(response.data.token);\n          this.setRefreshToken(response.data.refreshToken);\n          \n          // Atualizar usuário atual\n          if (response.data.usuario) {\n            this.currentUserSubject.next(response.data.usuario);\n          }\n        }\n        return response;\n      })\n    );\n  }\n\n  /**\n   * Realiza logout e remove tokens\n   */\n  logout(): void {\n    // O token será enviado automaticamente pelo interceptor\n    this.api.post('/auth/logout', {}).subscribe({\n      next: () => {\n        this.clearTokens();\n        this.currentUserSubject.next(null);\n        this.router.navigate(['/login']);\n      },\n      error: () => {\n        // Mesmo se falhar, limpar tokens localmente\n        this.clearTokens();\n        this.currentUserSubject.next(null);\n        this.router.navigate(['/login']);\n      },\n    });\n  }\n\n  /**\n   * Obtém informações do usuário atual\n   */\n  getCurrentUser(): Observable<any> {\n    return this.api.get<{ usuario: Usuario }>('/auth/me');\n  }\n\n  /**\n   * Renova o token usando refresh token\n   */\n  refreshToken(): Observable<any> {\n    const refreshToken = this.getRefreshToken();\n    \n    if (!refreshToken) {\n      return throwError(() => new Error('Refresh token não encontrado'));\n    }\n\n    return this.api.post<LoginResponse>('/auth/refresh', { refreshToken }).pipe(\n      map((response) => {\n        if (response.success && response.data) {\n          // Atualizar tokens\n          this.setToken(response.data.token);\n          this.setRefreshToken(response.data.refreshToken);\n          \n          return response;\n        }\n        throw new Error('Falha ao renovar token');\n      }),\n      catchError((error) => {\n        // Se refresh falhar, fazer logout\n        this.clearTokens();\n        this.currentUserSubject.next(null);\n        this.router.navigate(['/login']);\n        return throwError(() => error);\n      })\n    );\n  }\n\n  /**\n   * Verifica se o usuário está autenticado\n   */\n  isAuthenticated(): boolean {\n    return this.getToken() !== null && this.currentUserSubject.value !== null;\n  }\n\n  /**\n   * Obtém o token atual\n   */\n  getToken(): string | null {\n    return localStorage.getItem(this.TOKEN_KEY);\n  }\n\n  /**\n   * Obtém o refresh token atual\n   */\n  getRefreshToken(): string | null {\n    return localStorage.getItem(this.REFRESH_TOKEN_KEY);\n  }\n\n  /**\n   * Salva o token\n   */\n  private setToken(token: string): void {\n    localStorage.setItem(this.TOKEN_KEY, token);\n  }\n\n  /**\n   * Salva o refresh token\n   */\n  private setRefreshToken(refreshToken: string): void {\n    localStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);\n  }\n\n  /**\n   * Remove todos os tokens\n   */\n  private clearTokens(): void {\n    localStorage.removeItem(this.TOKEN_KEY);\n    localStorage.removeItem(this.REFRESH_TOKEN_KEY);\n  }\n\n  /**\n   * Verifica autenticação ao inicializar\n   */\n  private checkAuth(): void {\n    const token = this.getToken();\n    \n    if (!token) {\n      this.currentUserSubject.next(null);\n      return;\n    }\n\n    // Tentar obter informações do usuário\n    this.getCurrentUser().subscribe({\n      next: (response) => {\n        if (response.success && response.data?.usuario) {\n          this.currentUserSubject.next(response.data.usuario);\n        } else {\n          // Token inválido, limpar\n          this.clearTokens();\n          this.currentUserSubject.next(null);\n        }\n      },\n      error: () => {\n        // Erro ao validar token, tentar refresh\n        this.refreshToken().subscribe({\n          next: () => {\n            // Token renovado, tentar novamente\n            this.getCurrentUser().subscribe({\n              next: (response) => {\n                if (response.success && response.data?.usuario) {\n                  this.currentUserSubject.next(response.data.usuario);\n                }\n              },\n              error: () => {\n                this.clearTokens();\n                this.currentUserSubject.next(null);\n              },\n            });\n          },\n          error: () => {\n            // Refresh falhou, limpar tudo\n            this.clearTokens();\n            this.currentUserSubject.next(null);\n          },\n        });\n      },\n    });\n  }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}